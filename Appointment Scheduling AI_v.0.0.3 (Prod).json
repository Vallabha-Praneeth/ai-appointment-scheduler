{
  "name": "Appointment Scheduling AI_v.0.0.3 (Prod)",
  "nodes": [
    {
      "parameters": {
        "resource": "calendar",
        "calendar": {
          "__rl": true,
          "value": "quantumops9@gmail.com",
          "mode": "list",
          "cachedResultName": "quantumops9@gmail.com"
        },
        "timeMin": "={{ $json.startIso }}",
        "timeMax": "={{ $json.endIso }}",
        "options": {}
      },
      "id": "98b5c580-820b-4e12-8d93-173d476f291c",
      "name": "GCal (Check Availability)",
      "type": "n8n-nodes-base.googleCalendar",
      "typeVersion": 1.3,
      "position": [
        -1904,
        144
      ],
      "alwaysOutputData": true,
      "credentials": {
        "googleCalendarOAuth2Api": {
          "id": "0yByGfoje3gvnxgr",
          "name": "Google Calendar account 4"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// -------------------------------------------\n// Availability + Business Hours guard (single place)\n// -------------------------------------------\n\n// Pull Availability result from GCal node (boolean) if present\nconst gcalItems = $items(\"GCal (Check Availability)\") || [];\nconst availFromNode = gcalItems.find(i => typeof i.json?.available === \"boolean\")?.json?.available;\n\n// Requested slot & TZ\nconst tz = $json.tz || \"America/Chicago\";\nconst reqStartIso = $json.startIso;\nconst reqEndIso   = $json.endIso;\nconst reqStart = new Date(reqStartIso);\nconst reqEnd   = new Date(reqEndIso);\n\n// Business hours (10:00–18:00 local)\nconst OPEN_MIN  = 10 * 60;\nconst CLOSE_MIN = 18 * 60;\n\n// Helpers\nfunction minsLocal(iso, tz) {\n  const d = new Date(iso);\n  const parts = new Intl.DateTimeFormat('en-US', {\n    timeZone: tz, hour: '2-digit', minute: '2-digit', hour12: false\n  }).formatToParts(d);\n  const h = parseInt(parts.find(p => p.type === 'hour').value, 10);\n  const m = parseInt(parts.find(p => p.type === 'minute').value, 10);\n  return h * 60 + m;\n}\nfunction fmtLocal(iso, tz) {\n  return new Intl.DateTimeFormat('en-US', {\n    timeZone: tz,\n    year:'numeric', month:'2-digit', day:'2-digit',\n    hour:'2-digit', minute:'2-digit', hour12:false\n  }).format(new Date(iso));\n}\n\nconst startM = minsLocal(reqStartIso, tz);\nconst endM   = minsLocal(reqEndIso, tz);\nconst withinBusinessHours = (startM >= OPEN_MIN) && (endM <= CLOSE_MIN);\nconst localStart = fmtLocal(reqStartIso, tz);\nconst localEnd   = fmtLocal(reqEndIso, tz);\n\n// If Availability op gave us a boolean, trust it and AND with hours.\nif (typeof availFromNode === \"boolean\") {\n  const available = availFromNode && withinBusinessHours;\n  const reason =\n    !withinBusinessHours ? \"outside_business_hours\" :\n    (availFromNode === false ? \"calendar_conflict\" : undefined);\n\n  return [{\n    json: {\n      ...$json,\n      available,\n      businessHours: { tz, open: \"10:00\", close: \"18:00\", withinBusinessHours },\n      reason,\n      localStart,\n      localEnd,\n      conflicts: [] // Availability op doesn't return events\n    }\n  }];\n}\n\n// --------- Fallback path (if you switch to \"Get Events\") ----------\nfunction overlaps(aStart, aEnd, bStart, bEnd) {\n  return (aEnd.getTime() > bStart.getTime()) && (aStart.getTime() < bEnd.getTime());\n}\nfunction isPlaceholder(ev) {\n  const sum  = (ev.summary || \"\").trim();\n  const desc = (ev.description || \"\").toLowerCase();\n  const isSelf = ev.creator?.self === true;\n  return isSelf && (desc.includes(\"appointment (alt)\") || sum.startsWith(\"Name:\"));\n}\n\nconst conflicts = gcalItems\n  .map(i => i.json || {})\n  .filter(ev => {\n    if (isPlaceholder(ev)) return false;\n    const s = new Date(ev.start?.dateTime || ev.start || NaN);\n    const e = new Date(ev.end?.dateTime   || ev.end   || NaN);\n    if (Number.isNaN(s.getTime()) || Number.isNaN(e.getTime())) return false;\n    return overlaps(reqStart, reqEnd, s, e);\n  });\n\nconst available = (conflicts.length === 0) && withinBusinessHours;\nconst reason =\n  !withinBusinessHours ? \"outside_business_hours\" :\n  (conflicts.length ? \"calendar_conflict\" : undefined);\n\nreturn [{\n  json: {\n    ...$json,\n    available,\n    businessHours: { tz, open: \"10:00\", close: \"18:00\", withinBusinessHours },\n    reason,\n    localStart,\n    localEnd,\n    conflicts\n  }\n}];"
      },
      "id": "aca48772-b665-4dae-84f5-a30323acce16",
      "name": "Code (Availability Flag)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1456,
        144
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "55a94a4f-2629-4f29-b4e4-1b2935e9593d",
              "leftValue": "={{ $json.available }}",
              "rightValue": "yes",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "2a98d52e-0edd-49ea-9867-a7a43752e5e7",
      "name": "IF Available?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -1264,
        144
      ]
    },
    {
      "parameters": {
        "triggerTimes": {
          "item": [
            {
              "hour": 18
            }
          ]
        }
      },
      "id": "46f4d26c-e7ed-4b7d-a172-6b168de70045",
      "name": "Cron (Day Before)",
      "type": "n8n-nodes-base.cron",
      "typeVersion": 1,
      "position": [
        -2368,
        688
      ]
    },
    {
      "parameters": {
        "triggerTimes": {
          "item": [
            {
              "hour": 8
            }
          ]
        }
      },
      "id": "e004a626-bd29-4b5b-96e5-c779cc57b846",
      "name": "Cron (Same Day)",
      "type": "n8n-nodes-base.cron",
      "typeVersion": 1,
      "position": [
        -2352,
        992
      ]
    },
    {
      "parameters": {
        "operation": "getAll",
        "calendar": {
          "__rl": true,
          "value": "praneeth@quantum-ops.com",
          "mode": "list",
          "cachedResultName": "praneeth@quantum-ops.com"
        },
        "returnAll": true,
        "timeMin": "={{ new Date(Date.now()+24*60*60*1000).toISOString().slice(0,10) + 'T00:00:00.000Z' }}",
        "timeMax": "={{ new Date(Date.now()+24*60*60*1000).toISOString().slice(0,10) + 'T23:59:59.000Z' }}",
        "options": {}
      },
      "id": "5679a1a5-9410-4bc2-a2d8-95d1dd2044db",
      "name": "GCal (Events Tomorrow)",
      "type": "n8n-nodes-base.googleCalendar",
      "typeVersion": 1.3,
      "position": [
        -1984,
        688
      ],
      "credentials": {
        "googleCalendarOAuth2Api": {
          "id": "q8VNLUCeX67n7Bbs",
          "name": "Qops"
        }
      }
    },
    {
      "parameters": {
        "operation": "getAll",
        "calendar": {
          "__rl": true,
          "value": "praneeth@quantum-ops.com",
          "mode": "list",
          "cachedResultName": "praneeth@quantum-ops.com"
        },
        "returnAll": true,
        "timeMin": "={{ new Date().toISOString().slice(0,10) + 'T00:00:00.000Z' }}",
        "timeMax": "={{ new Date().toISOString().slice(0,10) + 'T23:59:59.000Z' }}",
        "options": {}
      },
      "id": "02cd502d-70bc-42ae-ae77-2f2f9cfecc65",
      "name": "GCal (Events Today)",
      "type": "n8n-nodes-base.googleCalendar",
      "typeVersion": 1.3,
      "position": [
        -1984,
        992
      ],
      "credentials": {
        "googleCalendarOAuth2Api": {
          "id": "q8VNLUCeX67n7Bbs",
          "name": "Qops"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// === SETTINGS ===\nconst TZ = 'America/Chicago';\nconst LOCALE = 'en-US';\n\n// --- helpers ---\nconst firstLine = s => (s || '').split('\\n')[0];\n\nfunction findPhone(ev) {\n  const blob = [ev.summary || '', ev.description || ''].join('\\n');\n  const m = blob.match(/phone\\s*[:\\-]?\\s*([+()\\-.\\s\\d]{7,})/i);\n  return m ? m[1] : '';\n}\n\nfunction toE164(raw) {\n  if (!raw) return '';\n  let d = raw.replace(/[^\\d+]/g, '');      // keep + and digits\n  if (d.startsWith('+')) return d;\n  // US default if 10 or 11 digits without +\n  if (d.length === 10) return '+1' + d;\n  if (d.length === 11 && d[0] === '1') return '+' + d;\n  return d; // let non-US (e.g. +91) pass through if already had +\n}\n\nfunction dayKey(date) {\n  // stable YYYY-MM-DD string in TZ\n  return date.toLocaleDateString('en-CA', { timeZone: TZ });\n}\n\nfunction whenLabel(dt) {\n  const t = new Date(dt);\n  const dKey = dayKey(t);\n  const today = dayKey(new Date());\n  const tomorrow = dayKey(new Date(Date.now() + 86400000));\n\n  const timePart = t.toLocaleString(LOCALE, {\n    timeZone: TZ,\n    hour: 'numeric',\n    minute: '2-digit',\n    timeZoneName: 'short',\n  });\n  const datePart = t.toLocaleDateString(LOCALE, {\n    timeZone: TZ,\n    weekday: 'short',\n    month: 'short',\n    day: 'numeric',\n  });\n\n  if (dKey === today) return `today at ${timePart}`;\n  if (dKey === tomorrow) return `tomorrow at ${timePart}`;\n  return `on ${datePart} at ${timePart}`;\n}\n\n// --- build messages ---\nconst out = [];\n\nfor (const it of items) {\n  const ev = it.json || {};\n\n  // event start: dateTime (timed) or date (all-day)\n  const startIso =\n    ev.start?.dateTime ||\n    (ev.start?.date ? `${ev.start.date}T00:00:00Z` : null);\n\n  if (!startIso) continue; // nothing to remind\n\n  // Subject: prefer a clean one-liner\n  let subject = firstLine(ev.summary);\n  // If description looks like \"Appointment (ALT): Name\", make that nicer\n  const alt = (ev.description || '').match(/appointment.*?:\\s*(.+)/i);\n  if ((!subject || /name:\\s*/i.test(subject)) && alt) {\n    subject = `Appointment: ${alt[1]}`;\n  }\n  if (!subject) subject = 'Appointment';\n\n  // phone: summary -> description -> (skip if missing)\n  const to = toE164(findPhone(ev));\n  if (!to || !/^\\+\\d{10,15}$/.test(to)) continue;\n\n  const when = whenLabel(startIso);\n\n  out.push({\n    json: {\n      to,\n      body: `Reminder: ${subject} ${when}. Reply YES to confirm or NO to reschedule.`,\n    },\n  });\n}\n\nreturn out;"
      },
      "id": "401fefe4-b0dc-40f6-8b67-c034c1305a68",
      "name": "Code (Build SMS)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1600,
        848
      ]
    },
    {
      "parameters": {
        "from": "+14694365607",
        "to": "={{ $json.to }}",
        "message": "={{ $json.body }}",
        "options": {}
      },
      "id": "54c2de59-f2c2-44e3-b3b5-0739d4c9e998",
      "name": "Twilio (Send SMS)",
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        -1312,
        848
      ],
      "credentials": {
        "twilioApi": {
          "id": "seXtNTssV0vIqTCu",
          "name": "Twilio account Full"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "88622cc8-204b-4ff4-b8a8-e45f344e2658",
              "leftValue": "={{ ($json.confirm ?? $json.output?.confirm ?? '').toString().trim().toLowerCase() }}",
              "rightValue": "yes",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -880,
        0
      ],
      "id": "bf3e0a35-eb5e-42fd-b257-e4502928c108",
      "name": "If Confirm"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// ---------- TIME WINDOW (America/Chicago aware) ----------\nconst TZ = $json.tz || 'America/Chicago';\n\n// Treat as ISO only if it has Z or an explicit offset\nconst isIsoZoned = s =>\n  typeof s === 'string' &&\n  /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}(?::\\d{2})?(?:Z|[+\\-]\\d{2}:\\d{2})$/.test(s?.trim?.() ?? '');\n\n// Helper: convert a JS Date that represents a *wall time* to the UTC instant\nfunction wallInTzToUtcISO(wallDate, timeZone) {\n  const inv = new Date(wallDate.toLocaleString('en-US', { timeZone }));\n  const diff = wallDate.getTime() - inv.getTime();\n  return new Date(wallDate.getTime() - diff).toISOString();\n}\n\n// Helper: now in Chicago (components)\nfunction nowPartsInTz(timeZone) {\n  const now = new Date();\n  const fmt = new Intl.DateTimeFormat('en-CA', {\n    timeZone, year: 'numeric', month: '2-digit', day: '2-digit',\n    hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false\n  });\n  const [ymd, hms] = fmt.format(now).split(', ');\n  const [y, m, d] = ymd.split('-').map(Number);\n  const [hh, mm, ss] = hms.split(':').map(Number);\n  return { y, m, d, hh, mm, ss };\n}\n\n// Parse “10”, “10am”, “10:30”, “3:15 pm”\nfunction parseTimeFromText(text) {\n  if (!text) return null;\n  const r = /\\b(\\d{1,2})(?::(\\d{2}))?\\s*(am|pm)?\\b/i;\n  const m = text.match(r);\n  if (!m) return null;\n  let hh = parseInt(m[1], 10);\n  const mm = m[2] ? parseInt(m[2], 10) : 0;\n  const ap = m[3]?.toLowerCase();\n  if (ap === 'am') { if (hh === 12) hh = 0; }\n  else if (ap === 'pm') { if (hh < 12) hh += 12; }\n  return { hh, mm };\n}\n\n/* ----------------------------------------------------------------\n   TEST OVERRIDE (safe): If this is our curl test for a busy slot,\n   force \"tomorrow 10:00–10:30\" in Chicago into $json so that the\n   rest of the code picks it up correctly.\n----------------------------------------------------------------- */\nif ($json?.source === 'test:busy-slot') {\n  const nowChi = new Date(new Date().toLocaleString('en-US', { timeZone: TZ }));\n  const y = nowChi.getFullYear(), m = nowChi.getMonth(), d = nowChi.getDate() + 1;\n\n  const wallStart = new Date(y, m, d, 10, 0, 0, 0);\n  const wallEnd   = new Date(y, m, d, 10, 30, 0, 0);\n\n  $json.startIso = wallInTzToUtcISO(wallStart, TZ);   // e.g. 2025-11-01T15:00:00Z\n  $json.endIso   = wallInTzToUtcISO(wallEnd,   TZ);   // e.g. 2025-11-01T15:30:00Z\n  $json.tz = TZ;\n}\n\n// Read the (possibly overridden) inputs\nconst rawStart = $json.startIso;\nconst rawEnd   = $json.endIso;\n\nlet startIso, endIso;\n\n// 1) If incoming already has Z/offset, trust it.\nif (isIsoZoned(rawStart)) {\n  startIso = new Date(rawStart.trim()).toISOString();\n  endIso   = isIsoZoned(rawEnd)\n    ? new Date(rawEnd.trim()).toISOString()\n    : new Date(new Date(startIso).getTime() + 30*60*1000).toISOString();\n\n} else {\n  // 2) Build from text like “tomorrow at 10am …”\n  const text =\n    ($json?.body?.message?.text) ||\n    ($json?.body?.message?.artifact?.transcript ?? '') ||\n    (($json?.body?.message?.artifact?.messages ?? [])\n      .filter(m => m?.role === 'user' && typeof m.message === 'string')\n      .map(m => m.message).join(' '));\n\n  const wantTomorrow = /\\btomorrow\\b/i.test(text);\n  const t = parseTimeFromText(text);\n\n  // Base date = now in Chicago, rounded to next top-of-hour\n  const nowTz = nowPartsInTz(TZ);\n  let y = nowTz.y, m = nowTz.m, d = nowTz.d, hh = nowTz.hh, mm = 0;\n\n  if (wantTomorrow) {\n    const wall = new Date(y, m - 1, d, 0, 0, 0);\n    wall.setDate(wall.getDate() + 1);\n    y = wall.getFullYear(); m = wall.getMonth() + 1; d = wall.getDate();\n  }\n\n  if (t) { hh = t.hh; mm = t.mm; }\n  else { hh = (hh + 1) % 24; mm = 0; }\n\n  const wallStart = new Date(y, m - 1, d, hh, mm, 0, 0);\n  startIso = wallInTzToUtcISO(wallStart, TZ);\n\n  if (isIsoZoned(rawEnd)) {\n    endIso = new Date(rawEnd.trim()).toISOString();\n  } else {\n    const wallEnd = new Date(wallStart.getTime() + 30*60*1000);\n    endIso = wallInTzToUtcISO(wallEnd, TZ);\n  }\n}\n\n// Output in your node’s current shape\nreturn {\n  json: {\n    ...$json,\n    startIso,\n    endIso,\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2064,
        144
      ],
      "id": "2e0b33c3-10e4-43ba-aef9-fdb6bb73d8d2",
      "name": "Code"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "c08dab76-7984-408a-9730-0f0464e75ad2",
        "responseMode": "responseNode",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [
        -3072,
        304
      ],
      "id": "e9eb5e39-18c5-4128-8d76-d942c8ddfee9",
      "name": "Webhook",
      "webhookId": "c08dab76-7984-408a-9730-0f0464e75ad2"
    },
    {
      "parameters": {
        "jsCode": "// --- Merge AI + Webhook identity, keep your date normalization ---\n\n// AI extractor output (schema mode returns { output: {...} })\nconst ai = $json.output ?? $json;\n\n// Webhook payload (authoritative identity)\nconst body = $item(0).$node[\"Webhook\"].json.body ?? {};\n\n// Prefer WEBHOOK for identity; AI for time-related fields & notes\nconst name     = body.name  ?? ai.name  ?? ai.fullName ?? null;\nconst phone    = body.phone ?? ai.phone ?? null;\nconst email    = body.email ?? ai.email ?? null;\n\nlet startIso   = ai.startIso ?? null;\nlet endIso     = ai.endIso   ?? null;\nconst confirm  = ai.confirm  ?? (body.confirm ?? null);\nconst notes    = ai.notes    ?? body.notes ?? null;\n\n// Carry timezone (default Chicago for this project)\nconst tz = body.tz ?? \"America/Chicago\";\n\n// --- Your date normalization stays the same ---\nfunction toDate(s) {\n  try { return s ? new Date(s) : null; } catch { return null; }\n}\n\nconst now = new Date();\nlet start = toDate(startIso);\nlet end   = toDate(endIso);\n\n// If start exists and is in the past, push 1 week forward\nif (start && start.getTime() <= now.getTime()) {\n  const next = new Date(start);\n  next.setDate(next.getDate() + 7);\n\n  const nextEnd = end ? new Date(end) : new Date(next.getTime() + 30*60*1000);\n  if (!end) end = nextEnd;\n  else nextEnd.setDate(nextEnd.getDate() + 7);\n\n  startIso = next.toISOString();\n  endIso   = nextEnd.toISOString();\n}\n\nreturn [{\n  json: {\n    // keep everything AI produced for forward-compat\n    ...ai,\n    name, phone, email,\n    startIso, endIso, confirm, notes, tz,\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2480,
        304
      ],
      "id": "5692a064-8290-4596-8d8d-9e0425eca7c1",
      "name": "Function"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "KhDrCjGH7a3eTdKe",
          "mode": "list",
          "cachedResultUrl": "/workflow/KhDrCjGH7a3eTdKe",
          "cachedResultName": "Appointment Scheduling AI_v.0.0.3 (If_Confrim_yes)"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {},
          "matchingColumns": [],
          "schema": [],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "options": {}
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.3,
      "position": [
        -592,
        -16
      ],
      "id": "34bbada3-326b-473e-916a-4d36de1af098",
      "name": "Call 'Appointment Scheduling AI_v.0.0.3 (If_Confrim_yes)'"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "kgC45JudCnRGR6gV",
          "mode": "list",
          "cachedResultUrl": "/workflow/kgC45JudCnRGR6gV",
          "cachedResultName": "Appointment Scheduling AI_v.0.0.3(If_Confirm_No)"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {}
        },
        "options": {}
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.3,
      "position": [
        -512,
        320
      ],
      "id": "95dcdfc7-18d0-4f6a-b00a-999b4a62d087",
      "name": "Call 'Appointment Scheduling AI_v.0.0.3(If_Confirm_No)'"
    },
    {
      "parameters": {
        "jsCode": "// Pull a \"confirm\" value from the current item or fall back to upstream nodes.\n// This handles cases where an intermediate node replaced the JSON (e.g., event-shaped data).\n\nfunction pick(...vals) {\n  for (const v of vals) if (v !== undefined && v !== null && String(v).trim() !== '') return v;\n  return '';\n}\n\nconst confirmRaw = pick(\n  $json.confirm,\n  $json.output?.confirm,\n  $item(0).$node?.[\"Function\"]?.json?.confirm,                           // normalization node\n  $item(0).$node?.[\"Code\"]?.json?.confirm,                                // code before GCal\n  $item(0).$node?.[\"AI — Extract Booking Fields\"]?.json?.output?.confirm  // AI result\n);\n\nconst normalized = confirmRaw.toString().trim().toLowerCase();\n\n// Optional: normalize common variants\nconst yesWords = ['yes','y','confirm','confirmed','ok','okay','sure'];\nconst noWords  = ['no','n','cancel','nope','later','reschedule','not now'];\n\nlet confirm = '';\nif (yesWords.includes(normalized)) confirm = 'yes';\nelse if (noWords.includes(normalized)) confirm = 'no';\nelse confirm = normalized || 'no'; // safe default\n\nreturn [{\n  json: {\n    ...$json,\n    confirm\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1072,
        0
      ],
      "id": "5bf31cf1-eb18-4786-8f54-580e7ae3e3c7",
      "name": "Ensure Confirm"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "mode": "list",
          "value": "gpt-4.1-mini"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        -2848,
        480
      ],
      "id": "e4585c13-b866-4658-80ba-fbe6e6ca1ad3",
      "name": "OpenAI Chat Model",
      "credentials": {
        "openAiApi": {
          "id": "4wHmecuhi3mYyPFp",
          "name": "My personal account"
        }
      }
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=You extract appointment info and return STRICT JSON.\n\nInterpretation rules:\n- Timezone is America/Chicago for all interpretation and output.\n- Current datetime (America/Chicago): {{ $now.setZone('America/Chicago').toISO() }}\n- If user gives a RELATIVE expression (e.g., “today 4pm”, “tomorrow 10am”, “next Fri 3:30”):\n  - Resolve to the next real calendar datetime in America/Chicago.\n  - If the resolved time has already passed today, move it forward appropriately\n    (e.g., tomorrow for “today”, or the next occurrence for “next Fri”).\n- If user gives an EXPLICIT, ZONED datetime (has Z or ±HH:MM), keep it as-is.\n  (Do NOT move explicit, zoned past dates.)\n- If only a start time is provided, set endIso = startIso + 30 minutes.\n- Names/phone/email may be null if not present.\n- Output only JSON. No extra text.\n\nOutput schema:\n{\n  \"name\": string|null,\n  \"phone\": string|null,\n  \"email\": string|null,\n  \"startIso\": ISO 8601 string WITH Chicago offset or null,   // e.g., 2025-11-01T10:00:00-05:00\n  \"endIso\":   ISO 8601 string WITH Chicago offset or null,\n  \"confirm\": \"yes\"|\"no\"|null,\n  \"notes\": string|null\n}",
        "hasOutputParser": true,
        "messages": {
          "messageValues": [
            {
              "message": "={{ $json.body?.message   ?? $json.body?.text   ?? '' }}"
            }
          ]
        },
        "batching": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.7,
      "position": [
        -2848,
        304
      ],
      "id": "85c38626-50df-4a8f-b015-85d1e0640c6d",
      "name": "AI — Extract Booking Fields"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "8b265f42-bfaa-4011-aec5-110eb71737c2",
              "leftValue": "={{ $json.startIso }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEmpty",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -2272,
        304
      ],
      "id": "28041791-77a0-4278-acff-1343f2fb529f",
      "name": "IF node “Slot Exists?”"
    },
    {
      "parameters": {
        "jsCode": "const name         = $json.name  ?? null;\nconst email        = $json.email ?? null;\nconst phone        = $json.phone ?? null;\nconst service_type = $json.service_type ?? null;\n\n// Default to America/Chicago for this project\nconst tz = $json.tz ?? \"America/Chicago\";\n\nreturn [{\n  json: {\n    result: \"need_more_info\",\n    missing: [\"appointment_request\"],   // i.e., the time\n    prompt: `I didn’t catch your preferred time. Please share a day and time (e.g., Tue 3:30 PM). I’ll check availability in ${tz}.`,\n    carry: {\n      name, email, phone, service_type,\n      timezone: tz\n    }\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -928,
        320
      ],
      "id": "edf57c97-ccd2-4cb7-8134-eb32322e4706",
      "name": "Mark NeedTime"
    },
    {
      "parameters": {
        "schemaType": "manual",
        "inputSchema": "={\n  \"type\": \"object\",\n  \"properties\": {\n    \"name\":    { \"type\": [\"string\", \"null\"] },\n    \"phone\":   { \"type\": [\"string\", \"null\"] },\n    \"email\":   { \"type\": [\"string\", \"null\"] },\n    \"startIso\":{ \"type\": [\"string\", \"null\"] },\n    \"endIso\":  { \"type\": [\"string\", \"null\"] },\n    \"confirm\": { \"enum\": [\"yes\", \"no\", null] },\n    \"notes\":   { \"type\": [\"string\", \"null\"] }\n  },\n  \"required\": [\"name\",\"phone\",\"email\",\"startIso\",\"endIso\",\"confirm\",\"notes\"],\n  \"additionalProperties\": false\n}",
        "autoFix": true
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.3,
      "position": [
        -2784,
        608
      ],
      "id": "4b809fcc-532d-4470-bc39-bff24818d24e",
      "name": "Structured Output Parser"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {}
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.4,
      "position": [
        -288,
        96
      ],
      "id": "4252e44e-39e9-4e1a-a6b1-4539752ec4ed",
      "name": "Respond to Webhook"
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        -1664,
        144
      ],
      "id": "f30b3a53-074a-4fc6-a11a-238867570366",
      "name": "Merge"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4o-mini",
          "mode": "list",
          "cachedResultName": "gpt-4o-mini"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        -2768,
        752
      ],
      "id": "ac8f3a96-0eb4-41ac-b319-eb93e9431458",
      "name": "OpenAI Chat Model1",
      "credentials": {
        "openAiApi": {
          "id": "4wHmecuhi3mYyPFp",
          "name": "My personal account"
        }
      }
    }
  ],
  "pinData": {
    "Webhook": [
      {
        "json": {
          "headers": {
            "host": "polarmedia.app.n8n.cloud",
            "user-agent": "curl/8.7.1",
            "content-length": "324",
            "accept": "*/*",
            "accept-encoding": "gzip, br",
            "cdn-loop": "cloudflare; loops=1; subreqs=1",
            "cf-connecting-ip": "2405:201:c001:7061:5990:f58c:39d7:19fa",
            "cf-ew-via": "15",
            "cf-ipcountry": "IN",
            "cf-ray": "998127ad5394c6f6-SIN",
            "cf-visitor": "{\"scheme\":\"https\"}",
            "cf-worker": "n8n.cloud",
            "content-type": "application/json",
            "x-forwarded-for": "2405:201:c001:7061:5990:f58c:39d7:19fa, 104.23.175.216",
            "x-forwarded-host": "polarmedia.app.n8n.cloud",
            "x-forwarded-port": "443",
            "x-forwarded-proto": "https",
            "x-forwarded-server": "traefik-prod-users-gwc-18-7959cfc789-rqqrl",
            "x-is-trusted": "yes",
            "x-real-ip": "2405:201:c001:7061:5990:f58c:39d7:19fa"
          },
          "params": {},
          "query": {},
          "body": {
            "source": "test:confirm-false",
            "message": "No, not that time. Suggest another.",
            "name": "Test User",
            "company": "QuantumOps IT Solutions",
            "email": "abcd@aaa.com",
            "phone": "11111111",
            "tz": "America/Chicago",
            "notes": "Confirm=false path test",
            "confirm": "no",
            "startIso": "2025-11-02T15:00:00-06:00",
            "endIso": "2025-11-02T15:30:00-06:00"
          },
          "webhookUrl": "https://polarmedia.app.n8n.cloud/webhook-test/vapi/call",
          "executionMode": "test"
        }
      }
    ]
  },
  "connections": {
    "GCal (Check Availability)": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Code (Availability Flag)": {
      "main": [
        [
          {
            "node": "IF Available?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF Available?": {
      "main": [
        [
          {
            "node": "Ensure Confirm",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Call 'Appointment Scheduling AI_v.0.0.3(If_Confirm_No)'",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Cron (Day Before)": {
      "main": [
        [
          {
            "node": "GCal (Events Tomorrow)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Cron (Same Day)": {
      "main": [
        [
          {
            "node": "GCal (Events Today)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "GCal (Events Tomorrow)": {
      "main": [
        [
          {
            "node": "Code (Build SMS)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "GCal (Events Today)": {
      "main": [
        [
          {
            "node": "Code (Build SMS)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code (Build SMS)": {
      "main": [
        [
          {
            "node": "Twilio (Send SMS)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If Confirm": {
      "main": [
        [
          {
            "node": "Call 'Appointment Scheduling AI_v.0.0.3 (If_Confrim_yes)'",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Call 'Appointment Scheduling AI_v.0.0.3(If_Confirm_No)'",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code": {
      "main": [
        [
          {
            "node": "GCal (Check Availability)",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Webhook": {
      "main": [
        [
          {
            "node": "AI — Extract Booking Fields",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Function": {
      "main": [
        [
          {
            "node": "IF node “Slot Exists?”",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Ensure Confirm": {
      "main": [
        [
          {
            "node": "If Confirm",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "AI — Extract Booking Fields",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "AI — Extract Booking Fields": {
      "main": [
        [
          {
            "node": "Function",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF node “Slot Exists?”": {
      "main": [
        [
          {
            "node": "Code",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Mark NeedTime",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Mark NeedTime": {
      "main": [
        [
          {
            "node": "Call 'Appointment Scheduling AI_v.0.0.3(If_Confirm_No)'",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser": {
      "ai_outputParser": [
        [
          {
            "node": "AI — Extract Booking Fields",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Call 'Appointment Scheduling AI_v.0.0.3 (If_Confrim_yes)'": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Call 'Appointment Scheduling AI_v.0.0.3(If_Confirm_No)'": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge": {
      "main": [
        [
          {
            "node": "Code (Availability Flag)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model1": {
      "ai_languageModel": [
        [
          {
            "node": "Structured Output Parser",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1",
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": false
  },
  "versionId": "f211d57d-ec66-4422-bfdc-f2920e50a789",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "00909d7feb8e9ba37a5e201aa76b7e43bb3e29d20ad98700fd8a52c9ea9d3d68"
  },
  "id": "LCebofVscCVrscBb",
  "tags": []
}