{
  "name": "Appointment Scheduling AI_v.0.0.3",
  "nodes": [
    {
      "parameters": {
        "operation": "getAll",
        "calendar": {
          "__rl": true,
          "value": "quantumops9@gmail.com",
          "mode": "list",
          "cachedResultName": "quantumops9@gmail.com"
        },
        "timeMin": "={{ $json.startIso }}",
        "timeMax": "={{ $json.endIso }}",
        "options": {}
      },
      "id": "cf765384-a41a-4e2e-9558-fbedb5233418",
      "name": "GCal (Check Availability)",
      "type": "n8n-nodes-base.googleCalendar",
      "typeVersion": 1.3,
      "position": [
        -1968,
        64
      ],
      "alwaysOutputData": true,
      "credentials": {
        "googleCalendarOAuth2Api": {
          "id": "0yByGfoje3gvnxgr",
          "name": "Google Calendar account 4"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// -------------------------------------------\n  // Availability + Business Hours guard (single place)\n  // -------------------------------------------\n\n  // Pull Availability result from GCal node (boolean) if present\n  const gcalItems = $items(\"GCal (Check Availability)\") || [];\n  const availFromNode = gcalItems.find(i => typeof i.json?.available === \"boolean\")?.json?.available;\n\n  // Requested slot & TZ\n  const tz = $json.tz || \"America/Chicago\";\n  const reqStartIso = $json.startIso;\n  const reqEndIso   = $json.endIso;\n  const reqStart = new Date(reqStartIso);\n  const reqEnd   = new Date(reqEndIso);\n\n  // Business hours (10:00–18:00 local)\n  const OPEN_MIN  = 10 * 60;\n  const CLOSE_MIN = 18 * 60;\n\n  // Helpers\n  function minsLocal(iso, tz) {\n    const d = new Date(iso);\n    const parts = new Intl.DateTimeFormat('en-US', {\n      timeZone: tz, hour: '2-digit', minute: '2-digit', hour12: false\n    }).formatToParts(d);\n    const h = parseInt(parts.find(p => p.type === 'hour').value, 10);\n    const m = parseInt(parts.find(p => p.type === 'minute').value, 10);\n    return h * 60 + m;\n  }\n  function fmtLocal(iso, tz) {\n    return new Intl.DateTimeFormat('en-US', {\n      timeZone: tz,\n      year:'numeric', month:'2-digit', day:'2-digit',\n      hour:'2-digit', minute:'2-digit', hour12:false\n    }).format(new Date(iso));\n  }\n\n  const startM = minsLocal(reqStartIso, tz);\n  const endM   = minsLocal(reqEndIso, tz);\n  const withinBusinessHours = (startM >= OPEN_MIN) && (endM <= CLOSE_MIN);\n  const localStart = fmtLocal(reqStartIso, tz);\n  const localEnd   = fmtLocal(reqEndIso, tz);\n\n  // If Availability op gave us a boolean, trust it and AND with hours.\n  if (typeof availFromNode === \"boolean\") {\n    const available = availFromNode && withinBusinessHours;\n    const reason =\n      !withinBusinessHours ? \"outside_business_hours\" :\n      (availFromNode === false ? \"calendar_conflict\" : undefined);\n\n    return [{\n      json: {\n        ...$json,\n        available,\n        businessHours: { tz, open: \"10:00\", close: \"18:00\", withinBusinessHours },\n        reason,\n        localStart,\n        localEnd,\n        conflicts: [] // Availability op doesn't return events\n      }\n    }];\n  }\n\n  // --------- Fallback path (if you switch to \"Get Events\") ----------\n  function overlaps(aStart, aEnd, bStart, bEnd) {\n    return (aEnd.getTime() > bStart.getTime()) && (aStart.getTime() < bEnd.getTime());\n  }\n  function isPlaceholder(ev) {\n    const sum  = (ev.summary || \"\").trim();\n    const desc = (ev.description || \"\").toLowerCase();\n    const isSelf = ev.creator?.self === true;\n    return isSelf && (desc.includes(\"appointment (alt)\") || sum.startsWith(\"Name:\"));\n  }\n\n  // Helper: Parse all-day events (date) or timed events (dateTime)\n  function parseEventTime(eventTime) {\n    if (!eventTime) return NaN;\n\n    // Timed event with dateTime\n    if (eventTime.dateTime) {\n      return new Date(eventTime.dateTime);\n    }\n\n    // All-day event with date only (e.g., \"2026-07-03\")\n    if (eventTime.date) {\n      // Parse as date in the target timezone at midnight\n      return new Date(eventTime.date + 'T00:00:00');\n    }\n\n    // Fallback: try parsing the object itself\n    return new Date(eventTime);\n  }\n\n  const conflicts = gcalItems\n    .map(i => i.json || {})\n    .filter(ev => {\n      if (isPlaceholder(ev)) return false;\n\n      const s = parseEventTime(ev.start);\n      const e = parseEventTime(ev.end);\n\n      if (Number.isNaN(s.getTime()) || Number.isNaN(e.getTime())) return false;\n      return overlaps(reqStart, reqEnd, s, e);\n    });\n\n  const available = (conflicts.length === 0) && withinBusinessHours;\n  const reason =\n    !withinBusinessHours ? \"outside_business_hours\" :\n    (conflicts.length ? \"calendar_conflict\" : undefined);\n\n  return [{\n    json: {\n      ...$json,\n      available,\n      businessHours: { tz, open: \"10:00\", close: \"18:00\", withinBusinessHours },\n      reason,\n      localStart,\n      localEnd,\n      conflicts\n    }\n  }];"
      },
      "id": "f3a7077a-af8b-46dc-8f0f-4373ff270c0b",
      "name": "Code (Availability Flag)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1456,
        64
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "55a94a4f-2629-4f29-b4e4-1b2935e9593d",
              "leftValue": "={{ $json.available }}",
              "rightValue": "yes",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "5bd99f72-2765-4b11-bb94-b654c103eb43",
      "name": "IF Available?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -1216,
        48
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "88622cc8-204b-4ff4-b8a8-e45f344e2658",
              "leftValue": "={{ ($json.confirm ?? $json.output?.confirm ?? '').toString().trim().toLowerCase() }}",
              "rightValue": "yes",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -752,
        32
      ],
      "id": "32c377ef-f9c5-4282-98c4-973bb547d61f",
      "name": "If Confirm"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// ---------- TIME WINDOW (America/Chicago aware) ----------\nconst TZ = $json.tz || 'America/Chicago';\n\n// Treat as ISO only if it has Z or an explicit offset\nconst isIsoZoned = s =>\n  typeof s === 'string' &&\n  /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}(?::\\d{2})?(?:Z|[+\\-]\\d{2}:\\d{2})$/.test(s?.trim?.() ?? '');\n\n// Helper: convert a JS Date that represents a *wall time* to the UTC instant\nfunction wallInTzToUtcISO(wallDate, timeZone) {\n  const inv = new Date(wallDate.toLocaleString('en-US', { timeZone }));\n  const diff = wallDate.getTime() - inv.getTime();\n  return new Date(wallDate.getTime() - diff).toISOString();\n}\n\n// Helper: now in Chicago (components)\nfunction nowPartsInTz(timeZone) {\n  const now = new Date();\n  const fmt = new Intl.DateTimeFormat('en-CA', {\n    timeZone, year: 'numeric', month: '2-digit', day: '2-digit',\n    hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false\n  });\n  const [ymd, hms] = fmt.format(now).split(', ');\n  const [y, m, d] = ymd.split('-').map(Number);\n  const [hh, mm, ss] = hms.split(':').map(Number);\n  return { y, m, d, hh, mm, ss };\n}\n\n// Parse “10”, “10am”, “10:30”, “3:15 pm”\nfunction parseTimeFromText(text) {\n  if (!text) return null;\n  const r = /\\b(\\d{1,2})(?::(\\d{2}))?\\s*(am|pm)?\\b/i;\n  const m = text.match(r);\n  if (!m) return null;\n  let hh = parseInt(m[1], 10);\n  const mm = m[2] ? parseInt(m[2], 10) : 0;\n  const ap = m[3]?.toLowerCase();\n  if (ap === 'am') { if (hh === 12) hh = 0; }\n  else if (ap === 'pm') { if (hh < 12) hh += 12; }\n  return { hh, mm };\n}\n\n/* ----------------------------------------------------------------\n   TEST OVERRIDE (safe): If this is our curl test for a busy slot,\n   force \"tomorrow 10:00–10:30\" in Chicago into $json so that the\n   rest of the code picks it up correctly.\n----------------------------------------------------------------- */\nif ($json?.source === 'test:busy-slot') {\n  const nowChi = new Date(new Date().toLocaleString('en-US', { timeZone: TZ }));\n  const y = nowChi.getFullYear(), m = nowChi.getMonth(), d = nowChi.getDate() + 1;\n\n  const wallStart = new Date(y, m, d, 10, 0, 0, 0);\n  const wallEnd   = new Date(y, m, d, 10, 30, 0, 0);\n\n  $json.startIso = wallInTzToUtcISO(wallStart, TZ);   // e.g. 2025-11-01T15:00:00Z\n  $json.endIso   = wallInTzToUtcISO(wallEnd,   TZ);   // e.g. 2025-11-01T15:30:00Z\n  $json.tz = TZ;\n}\n\n// Read the (possibly overridden) inputs\nconst rawStart = $json.startIso;\nconst rawEnd   = $json.endIso;\n\nlet startIso, endIso;\n\n// 1) If incoming already has Z/offset, trust it.\nif (isIsoZoned(rawStart)) {\n  startIso = new Date(rawStart.trim()).toISOString();\n  endIso   = isIsoZoned(rawEnd)\n    ? new Date(rawEnd.trim()).toISOString()\n    : new Date(new Date(startIso).getTime() + 30*60*1000).toISOString();\n\n} else {\n  // 2) Build from text like “tomorrow at 10am …”\n  const text =\n    ($json?.body?.message?.text) ||\n    ($json?.body?.message?.artifact?.transcript ?? '') ||\n    (($json?.body?.message?.artifact?.messages ?? [])\n      .filter(m => m?.role === 'user' && typeof m.message === 'string')\n      .map(m => m.message).join(' '));\n\n  const wantTomorrow = /\\btomorrow\\b/i.test(text);\n  const t = parseTimeFromText(text);\n\n  // Base date = now in Chicago, rounded to next top-of-hour\n  const nowTz = nowPartsInTz(TZ);\n  let y = nowTz.y, m = nowTz.m, d = nowTz.d, hh = nowTz.hh, mm = 0;\n\n  if (wantTomorrow) {\n    const wall = new Date(y, m - 1, d, 0, 0, 0);\n    wall.setDate(wall.getDate() + 1);\n    y = wall.getFullYear(); m = wall.getMonth() + 1; d = wall.getDate();\n  }\n\n  if (t) { hh = t.hh; mm = t.mm; }\n  else { hh = (hh + 1) % 24; mm = 0; }\n\n  const wallStart = new Date(y, m - 1, d, hh, mm, 0, 0);\n  startIso = wallInTzToUtcISO(wallStart, TZ);\n\n  if (isIsoZoned(rawEnd)) {\n    endIso = new Date(rawEnd.trim()).toISOString();\n  } else {\n    const wallEnd = new Date(wallStart.getTime() + 30*60*1000);\n    endIso = wallInTzToUtcISO(wallEnd, TZ);\n  }\n}\n\n// Output in your node’s current shape\nreturn {\n  json: {\n    ...$json,\n    startIso,\n    endIso,\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2160,
        64
      ],
      "id": "253fba1f-64f9-4b46-bf11-57c19f6f3f42",
      "name": "Code"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "vapi/call",
        "authentication": "headerAuth",
        "responseMode": "responseNode",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [
        -3200,
        336
      ],
      "id": "90bebdc3-895f-4f90-823c-688fed468542",
      "name": "Webhook",
      "webhookId": "72212877-5c69-499c-a97d-cf609765e8de",
      "credentials": {
        "httpHeaderAuth": {
          "id": "mtbZQ3YR4VQJHsPz",
          "name": "Webhook Secret"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// --- Merge AI + Webhook identity, keep your date normalization ---\n\n// AI extractor output (schema mode returns { output: {...} })\nconst ai = $json.output ?? $json;\n\n// Webhook payload (authoritative identity)\nconst body = $item(0).$node[\"Webhook\"].json.body ?? {};\n\n// Prefer WEBHOOK for identity; AI for time-related fields & notes\nconst name     = body.name  ?? ai.name  ?? ai.fullName ?? null;\nconst phone    = body.phone ?? ai.phone ?? null;\nconst email    = body.email ?? ai.email ?? null;\n\nlet startIso   = ai.startIso ?? null;\nlet endIso     = ai.endIso   ?? null;\nconst confirm  = ai.confirm  ?? (body.confirm ?? null);\nconst notes    = ai.notes    ?? body.notes ?? null;\n\n// Carry timezone (default Chicago for this project)\nconst tz = body.tz ?? \"America/Chicago\";\n\n// --- Your date normalization stays the same ---\nfunction toDate(s) {\n  try { return s ? new Date(s) : null; } catch { return null; }\n}\n\nconst now = new Date();\nlet start = toDate(startIso);\nlet end   = toDate(endIso);\n\n// If start exists and is in the past, push 1 week forward\nif (start && start.getTime() <= now.getTime()) {\n  const next = new Date(start);\n  next.setDate(next.getDate() + 7);\n\n  const nextEnd = end ? new Date(end) : new Date(next.getTime() + 30*60*1000);\n  if (!end) end = nextEnd;\n  else nextEnd.setDate(nextEnd.getDate() + 7);\n\n  startIso = next.toISOString();\n  endIso   = nextEnd.toISOString();\n}\n\nreturn [{\n  json: {\n    // keep everything AI produced for forward-compat\n    ...ai,\n    name, phone, email,\n    startIso, endIso, confirm, notes, tz,\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2352,
        336
      ],
      "id": "2bd49cc9-e7a0-4a59-9e4f-f27bf19b90aa",
      "name": "Function"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "KhDrCjGH7a3eTdKe",
          "mode": "list",
          "cachedResultUrl": "/workflow/KhDrCjGH7a3eTdKe",
          "cachedResultName": "Appointment Scheduling AI_v.0.0.3 (If_Confrim_yes)"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {},
          "matchingColumns": [],
          "schema": [],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "options": {}
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.3,
      "position": [
        -464,
        16
      ],
      "id": "38f45bcb-75da-463c-b82d-1ace27b810a4",
      "name": "Call 'Appointment Scheduling AI_v.0.0.3 (If_Confrim_yes)'"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "kgC45JudCnRGR6gV",
          "mode": "list",
          "cachedResultUrl": "/workflow/kgC45JudCnRGR6gV",
          "cachedResultName": "Appointment Scheduling AI_v.0.0.3(If_Confirm_No)"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {}
        },
        "options": {}
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.3,
      "position": [
        -384,
        352
      ],
      "id": "3c67620a-397e-4627-85d3-81030386a578",
      "name": "Call 'Appointment Scheduling AI_v.0.0.3(If_Confirm_No)'"
    },
    {
      "parameters": {
        "jsCode": "// Pull a \"confirm\" value from the current item or fall back to upstream nodes.\n// This handles cases where an intermediate node replaced the JSON (e.g., event-shaped data).\n\nfunction pick(...vals) {\n  for (const v of vals) if (v !== undefined && v !== null && String(v).trim() !== '') return v;\n  return '';\n}\n\nconst confirmRaw = pick(\n  $json.confirm,\n  $json.output?.confirm,\n  $item(0).$node?.[\"Function\"]?.json?.confirm,                           // normalization node\n  $item(0).$node?.[\"Code\"]?.json?.confirm,                                // code before GCal\n  $item(0).$node?.[\"AI — Extract Booking Fields\"]?.json?.output?.confirm  // AI result\n);\n\nconst normalized = confirmRaw.toString().trim().toLowerCase();\n\n// Optional: normalize common variants\nconst yesWords = ['yes','y','confirm','confirmed','ok','okay','sure'];\nconst noWords  = ['no','n','cancel','nope','later','reschedule','not now'];\n\nlet confirm = '';\nif (yesWords.includes(normalized)) confirm = 'yes';\nelse if (noWords.includes(normalized)) confirm = 'no';\nelse confirm = normalized || 'no'; // safe default\n\nreturn [{\n  json: {\n    ...$json,\n    confirm\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -944,
        32
      ],
      "id": "070ddcea-0c23-4bd2-9c0c-425af124c6b7",
      "name": "Ensure Confirm"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "mode": "list",
          "value": "gpt-4.1-mini"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        -2720,
        512
      ],
      "id": "dcba93bf-d545-4e2b-9e4f-ab8b2c8449c1",
      "name": "OpenAI Chat Model",
      "credentials": {
        "openAiApi": {
          "id": "4wHmecuhi3mYyPFp",
          "name": "My personal account"
        }
      }
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=You extract appointment info and return STRICT JSON.\n\nInterpretation rules:\n- Timezone is America/Chicago for all interpretation and output.\n- Current datetime (America/Chicago): {{ $now.setZone('America/Chicago').toISO() }}\n- If user gives a RELATIVE expression (e.g., “today 4pm”, “tomorrow 10am”, “next Fri 3:30”):\n  - Resolve to the next real calendar datetime in America/Chicago.\n  - If the resolved time has already passed today, move it forward appropriately\n    (e.g., tomorrow for “today”, or the next occurrence for “next Fri”).\n- If user gives an EXPLICIT, ZONED datetime (has Z or ±HH:MM), keep it as-is.\n  (Do NOT move explicit, zoned past dates.)\n- If only a start time is provided, set endIso = startIso + 30 minutes.\n- Names/phone/email may be null if not present.\n- Output only JSON. No extra text.\n\nOutput schema:\n{\n  \"name\": string|null,\n  \"phone\": string|null,\n  \"email\": string|null,\n  \"startIso\": ISO 8601 string WITH Chicago offset or null,   // e.g., 2025-11-01T10:00:00-05:00\n  \"endIso\":   ISO 8601 string WITH Chicago offset or null,\n  \"confirm\": \"yes\"|\"no\"|null,\n  \"notes\": string|null\n}",
        "hasOutputParser": true,
        "messages": {
          "messageValues": [
            {
              "message": "={{\n(() => {\n  const b = $json.body || {};\n  const last = (arr) => Array.isArray(arr) && arr.length ? arr[arr.length-1] : undefined;\n\n  // 1) Last user message (artifact.messages)\n  const m1 = last((b.artifact?.messages || []).filter(m => m?.role === 'user'))?.message;\n  if (typeof m1 === 'string' && m1.trim()) return m1;\n\n  // 2) Last user message (messagesOpenAIFormatted)\n  const m2 = last((b.artifact?.messagesOpenAIFormatted || []).filter(m => m?.role === 'user'))?.content;\n  if (typeof m2 === 'string' && m2.trim()) return m2;\n\n  // 3) Tool call arguments (message.toolCalls / toolCallList)\n  const tc = (b.message?.toolCalls || b.message?.toolCallList || []);\n  const a3 = tc[0]?.function?.arguments;\n  if (a3) return typeof a3 === 'string' ? a3 : JSON.stringify(a3);\n\n  // 4) ToolWithToolCallList -> toolCall -> function.arguments\n  const tw = (b.message?.toolWithToolCallList || []);\n  const a4 = tw[0]?.toolCall?.function?.arguments;\n  if (a4) return typeof a4 === 'string' ? a4 : JSON.stringify(a4);\n\n  // 5) Raw strings\n  const mm = b.message?.message;\n  if (typeof mm === 'string' && mm) return mm;\n\n  if (typeof b.text === 'string') return b.text;\n\n  return '';\n})()\n}}"
            }
          ]
        },
        "batching": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.7,
      "position": [
        -2720,
        336
      ],
      "id": "27cf65de-d2e1-4724-a309-7f443c92f12a",
      "name": "AI — Extract Booking Fields"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "8b265f42-bfaa-4011-aec5-110eb71737c2",
              "leftValue": "={{ $json.startIso }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEmpty",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -2144,
        336
      ],
      "id": "d7ea97bd-e073-4cb2-af18-f6203af1b5ba",
      "name": "IF node “Slot Exists?”"
    },
    {
      "parameters": {
        "jsCode": "const name         = $json.name  ?? null;\nconst email        = $json.email ?? null;\nconst phone        = $json.phone ?? null;\nconst service_type = $json.service_type ?? null;\n\n// Default to America/Chicago for this project\nconst tz = $json.tz ?? \"America/Chicago\";\n\nreturn [{\n  json: {\n    result: \"need_more_info\",\n    missing: [\"appointment_request\"],   // i.e., the time\n    prompt: `I didn’t catch your preferred time. Please share a day and time (e.g., Tue 3:30 PM). I’ll check availability in ${tz}.`,\n    carry: {\n      name, email, phone, service_type,\n      timezone: tz\n    }\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -800,
        352
      ],
      "id": "cd339250-0c75-49f9-90c8-b1a7b9ebb9cd",
      "name": "Mark NeedTime"
    },
    {
      "parameters": {
        "schemaType": "manual",
        "inputSchema": "={\n  \"type\": \"object\",\n  \"properties\": {\n    \"name\":    { \"type\": [\"string\", \"null\"] },\n    \"phone\":   { \"type\": [\"string\", \"null\"] },\n    \"email\":   { \"type\": [\"string\", \"null\"] },\n    \"startIso\":{ \"type\": [\"string\", \"null\"] },\n    \"endIso\":  { \"type\": [\"string\", \"null\"] },\n    \"confirm\": { \"enum\": [\"yes\", \"no\", null] },\n    \"notes\":   { \"type\": [\"string\", \"null\"] }\n  },\n  \"required\": [\"name\",\"phone\",\"email\",\"startIso\",\"endIso\",\"confirm\",\"notes\"],\n  \"additionalProperties\": false\n}",
        "autoFix": true
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.3,
      "position": [
        -2656,
        640
      ],
      "id": "c1923afb-19ee-4b08-9b83-6c4b5c25b68b",
      "name": "Structured Output Parser"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{$item(0).$json}}",
        "options": {
          "responseCode": 200,
          "responseHeaders": {
            "entries": [
              {
                "name": "Content-Type",
                "value": "application/json"
              }
            ]
          }
        }
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.4,
      "position": [
        80,
        176
      ],
      "id": "9a565d05-38ce-4dae-9467-ed96ea9240d4",
      "name": "Respond to Webhook"
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        -1728,
        64
      ],
      "id": "0671207c-f95a-4526-b181-2a584bd96405",
      "name": "Merge"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4o-mini",
          "mode": "list",
          "cachedResultName": "gpt-4o-mini"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        -2640,
        784
      ],
      "id": "0e575dc4-d29d-4d21-8efe-c75e69604878",
      "name": "OpenAI Chat Model1",
      "credentials": {
        "openAiApi": {
          "id": "4wHmecuhi3mYyPFp",
          "name": "My personal account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// 1) Get the toolCallId that Vapi sent\nconst callId =\n  $item(0).$node[\"Webhook\"]?.json?.body?.message?.toolCalls?.[0]?.id ||\n  $item(0).$node[\"Webhook\"]?.json?.body?.message?.toolCallList?.[0]?.id ||\n  $json?.toolCallId || \"\";\n\n// 2) Get the booking payload you already produced upstream\n//    (fallback to current item if needed)\nconst payload =\n  $json?.result ? $json :\n  ($item(0).$node[\"Call 'Appointment Scheduling AI_v.0.0.3 (If_Confirm_yes)'\"]?.json || $json);\n\n// 3) Wrap exactly as Vapi expects: results[{ toolCallId, result: \"<string>\" }]\nreturn [{\n  json: {\n    results: [{\n      toolCallId: callId,\n      result: JSON.stringify(payload)   // <- STRING\n      // For failures, use: error: JSON.stringify(payload)\n    }]\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -256,
        16
      ],
      "id": "d3b9b390-ba29-44d6-9c04-e08af72ec327",
      "name": "Vapi Wrapper"
    },
    {
      "parameters": {
        "jsCode": "// --- Extract the Vapi toolCallId from the inbound webhook ---\nconst callId =\n  $item(0).$node[\"Webhook\"]?.json?.body?.message?.toolCalls?.[0]?.id ||\n  $item(0).$node[\"Webhook\"]?.json?.body?.message?.toolCallList?.[0]?.id ||\n  $json?.toolCallId || \"\";\n\n// --- Pick your upstream payload (the node that produced final result) ---\n// Prefer the most recent node that created { result: \"...\", ... }.\n// If your node names differ, update the reference below.\nconst upstream =\n  $json?.result ? $json :\n  $item(0).$prevNode?.json || $json;\n\n// --- Choose success vs error key dynamically ---\nconst isError = !!upstream?.error || upstream?.result === \"error\";\n\nreturn [{\n  json: {\n    results: [{\n      toolCallId: callId,\n      [isError ? \"error\" : \"result\"]: JSON.stringify(upstream)\n    }]\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -176,
        352
      ],
      "id": "e8eae98f-7989-4a0c-a7ef-c1d25aecfb28",
      "name": "Vapi Wrapper1"
    },
    {
      "parameters": {
        "jsCode": "// INPUT VALIDATION\n  const body = $json.body || $json;\n  const args = body?.message?.toolCalls?.[0]?.function?.arguments;\n\n  let input = {};\n  if (typeof args === 'string') {\n    try { input = JSON.parse(args); } catch (e) { input = body; }\n  } else {\n    input = args || body;\n  }\n\n  // Validate phone\n  function validatePhone(raw) {\n    if (!raw) return null;\n    const digits = String(raw).replace(/\\D/g, '');\n    if (digits.length < 7 || digits.length > 15) return null;\n    if (digits.length === 10) return '+1' + digits;\n    if (digits.length === 11 && digits[0] === '1') return '+' + digits;\n    return '+' + digits;\n  }\n\n  // Sanitize name (remove XSS characters)\n  function sanitizeName(raw) {\n    if (!raw) return null;\n    return String(raw).replace(/[<>\\\"\\'&]/g, '').trim().substring(0, 100);\n  }\n\n  // Validate email\n  function validateEmail(raw) {\n    if (!raw) return null;\n    const email = String(raw).trim().toLowerCase();\n    return /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(email) ? email : null;\n  }\n\n  // Apply validation\n  const validated = {\n    phone: validatePhone(input.phone),\n    name: sanitizeName(input.name || input.fullName),\n    email: validateEmail(input.email),\n    service_type: ['support','maintenance','consultation','onsite','emergency']\n      .includes(String(input.service_type || '').toLowerCase())\n      ? String(input.service_type).toLowerCase()\n      : 'consultation',\n    timezone: input.timezone || input.tz || 'America/Chicago',\n    startIso: input.startIso,\n    endIso: input.endIso,\n    confirm: input.confirm || \"\"\n  };\n\n  return { json: { ...$json, ...validated, _validated: true } };"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2960,
        336
      ],
      "id": "3abf8404-a1b2-42c0-881c-5477c4148b87",
      "name": "Validate Input"
    },
    {
      "parameters": {},
      "id": "7b080f6c-6621-4fa5-9272-53100dae61a9",
      "name": "Error Trigger",
      "type": "n8n-nodes-base.errorTrigger",
      "typeVersion": 1,
      "position": [
        -3200,
        16
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://polarmedia.app.n8n.cloud/webhook/error-handle",
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "workflowName",
              "value": "={{$workflow.name}}"
            },
            {
              "name": "workflowId",
              "value": "={{$workflow.id}}"
            },
            {
              "name": "executionId",
              "value": "={{$execution.id}}"
            },
            {
              "name": "errorMessage",
              "value": "={{$json.error.message}}"
            },
            {
              "name": "errorNode",
              "value": "={{$json.node.name}}"
            },
            {
              "name": "timestamp",
              "value": "={{$now.toISO()}}"
            }
          ]
        },
        "options": {
          "response": {
            "response": {}
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        -2992,
        16
      ],
      "id": "b482a8e5-8aae-47dd-ab09-883b42cfd580",
      "name": "HTTP Request"
    },
    {
      "parameters": {
        "jsCode": "const reason = $json.reason || \"calendar_conflict\";\n  const localStart = $json.localStart || \"\";\n  const localEnd = $json.localEnd || \"\";\n\n  let message = \"❌ That time slot is not available.\";\n  if (reason === \"calendar_conflict\") {\n    message = \"❌ That time is already booked or the office is closed.\";\n  } else if (reason === \"outside_business_hours\") {\n    message = \"❌ That time is outside business hours (10 AM - 6 PM).\";\n  }\n\n  return [{\n    json: {\n      result: \"no_free_slot\",\n      available: false,\n      reason: reason,\n      message: message,\n      requestedSlot: {\n        start: localStart,\n        end: localEnd\n      }\n    }\n  }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -592,
        656
      ],
      "id": "7d607de3-626b-4288-9bc1-0a30efc9c280",
      "name": "Return Unavailable"
    }
  ],
  "pinData": {
    "Webhook": [
      {
        "json": {
          "headers": {
            "host": "polarmedia.app.n8n.cloud",
            "user-agent": "curl/8.7.1",
            "content-length": "623",
            "accept": "*/*",
            "accept-encoding": "gzip, br",
            "cdn-loop": "cloudflare; loops=1; subreqs=1",
            "cf-connecting-ip": "2405:201:c001:7061:6164:5dcb:a51:c45e",
            "cf-ew-via": "15",
            "cf-ipcountry": "IN",
            "cf-ray": "9a8272c2146b85f0-BOM",
            "cf-visitor": "{\"scheme\":\"https\"}",
            "cf-worker": "n8n.cloud",
            "content-type": "application/json",
            "x-forwarded-for": "2405:201:c001:7061:6164:5dcb:a51:c45e, 172.70.218.53",
            "x-forwarded-host": "polarmedia.app.n8n.cloud",
            "x-forwarded-port": "443",
            "x-forwarded-proto": "https",
            "x-forwarded-server": "traefik-prod-users-gwc-18-7959cfc789-rqqrl",
            "x-is-trusted": "yes",
            "x-real-ip": "2405:201:c001:7061:6164:5dcb:a51:c45e",
            "x-webhook-secret": "xhk1VWWfjGDb8lm3Nyz1C15eBv+wKnHFCEkSG0DESE0="
          },
          "params": {},
          "query": {},
          "body": {
            "message": {
              "type": "tool-calls",
              "toolCalls": [
                {
                  "id": "test_holiday_thanksgiving",
                  "function": {
                    "name": "function_tool",
                    "arguments": {
                      "name": "Holiday Test User",
                      "email": "holiday@test.com",
                      "phone": "+12145551234",
                      "title": "Test Thanksgiving Booking",
                      "startIso": "2025-11-27T10:00:00-06:00",
                      "endIso": "2025-11-27T11:00:00-06:00",
                      "timezone": "America/Chicago",
                      "service_type": "consultation",
                      "confirm": "yes"
                    }
                  }
                }
              ]
            }
          },
          "webhookUrl": "https://polarmedia.app.n8n.cloud/webhook/vapi/call",
          "executionMode": "production"
        }
      }
    ]
  },
  "connections": {
    "GCal (Check Availability)": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Code (Availability Flag)": {
      "main": [
        [
          {
            "node": "IF Available?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF Available?": {
      "main": [
        [
          {
            "node": "Ensure Confirm",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Return Unavailable",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If Confirm": {
      "main": [
        [
          {
            "node": "Call 'Appointment Scheduling AI_v.0.0.3 (If_Confrim_yes)'",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Call 'Appointment Scheduling AI_v.0.0.3(If_Confirm_No)'",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code": {
      "main": [
        [
          {
            "node": "GCal (Check Availability)",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Webhook": {
      "main": [
        [
          {
            "node": "Validate Input",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Function": {
      "main": [
        [
          {
            "node": "IF node “Slot Exists?”",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Ensure Confirm": {
      "main": [
        [
          {
            "node": "If Confirm",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "AI — Extract Booking Fields",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "AI — Extract Booking Fields": {
      "main": [
        [
          {
            "node": "Function",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF node “Slot Exists?”": {
      "main": [
        [
          {
            "node": "Code",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Mark NeedTime",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Mark NeedTime": {
      "main": [
        [
          {
            "node": "Call 'Appointment Scheduling AI_v.0.0.3(If_Confirm_No)'",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser": {
      "ai_outputParser": [
        [
          {
            "node": "AI — Extract Booking Fields",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Call 'Appointment Scheduling AI_v.0.0.3 (If_Confrim_yes)'": {
      "main": [
        [
          {
            "node": "Vapi Wrapper",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Call 'Appointment Scheduling AI_v.0.0.3(If_Confirm_No)'": {
      "main": [
        [
          {
            "node": "Vapi Wrapper1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge": {
      "main": [
        [
          {
            "node": "Code (Availability Flag)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model1": {
      "ai_languageModel": [
        [
          {
            "node": "Structured Output Parser",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Vapi Wrapper": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Vapi Wrapper1": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Input": {
      "main": [
        [
          {
            "node": "AI — Extract Booking Fields",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Error Trigger": {
      "main": [
        [
          {
            "node": "HTTP Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Return Unavailable": {
      "main": [
        [
          {
            "node": "Vapi Wrapper1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1",
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": false,
    "errorWorkflow": "tG0jYV0MZubLn7dJ"
  },
  "versionId": "e8e9be03-8d65-426a-874f-9fa1e834ae34",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "00909d7feb8e9ba37a5e201aa76b7e43bb3e29d20ad98700fd8a52c9ea9d3d68"
  },
  "id": "LyMkBzWpdRdXVfHD",
  "tags": []
}